import {
  // assertStrictEquals as is,
  assertEquals as eq,
  assertThrows as throws,
} from 'assert'

import * as f from '../fpx.mjs'

const STASH = []
function stash(value, key, a, b, c) {STASH.push([value, key, a, b, c])}
function foldStash(acc, value, key, a, b, c) {STASH.push([acc, value, key, a, b, c])}
function unstash() {return STASH.splice(0)}

function id   (a)    {return a}
function add  (a, b) {return a + b}

eq(f.size(),                   0)
eq(f.size(null),               0)
eq(f.size(undefined),          0)
eq(f.size({}),                 0)
eq(f.size({one: 10}),          1)
eq(f.size({one: 10, two: 20}), 2)
throws(() => f.size(10))
throws(() => f.size('one'))
throws(() => f.size(new String('one')))
throws(() => f.size([10]))
throws(() => f.size(f.size))

eq(f.hasSize(),                   false)
eq(f.hasSize(null),               false)
eq(f.hasSize(undefined),          false)
eq(f.hasSize({}),                 false)
eq(f.hasSize({one: 10}),          true)
eq(f.hasSize({one: 10, two: 20}), true)
eq(f.hasSize(10),                 false)
eq(f.hasSize('one'),              false)
eq(f.hasSize(new String('one')),  false)
eq(f.hasSize([10]),               false)
eq(f.hasSize(f.hasSize),          false)

eq(f.keys(),                   [])
eq(f.keys(null),               [])
eq(f.keys({one: 10, two: 20}), ['one', 'two'])
throws(() => f.keys(10))
throws(() => f.keys('blah'))
throws(() => f.keys(f.keys))
throws(() => f.keys(['not struct']))

eq(f.vals(),                   [])
eq(f.vals(null),               [])
eq(f.vals({one: 10, two: 20}), [10, 20])
throws(() => f.vals(10))
throws(() => f.vals('blah'))
throws(() => f.vals(f.vals))
throws(() => f.vals(['not struct']))

eq(f.entries(),                   [])
eq(f.entries(null),               [])
eq(f.entries({one: 10, two: 20}), [['one', 10], ['two', 20]])
throws(() => f.entries(10))
throws(() => f.entries('blah'))
throws(() => f.entries(f.entries))
throws(() => f.entries(['not struct']))

eq(f.eachVal(undefined, id), undefined)
f.eachVal({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.eachVal)
throws(() => f.eachVal(f.eachVal, id))
throws(() => f.eachVal('not struct', id))
throws(() => f.eachVal(['not struct'], id))

eq(f.foldVals(undefined, 10, add), 10)
eq(f.foldVals({one: 20, two: 30}, 10, add), 60)
f.foldVals({one: 10, two: 20}, 5, foldStash, 10, 20, 30)
eq(unstash(), [[5, 10, 'one', 10, 20, 30], [undefined, 20, 'two', 10, 20, 30]])
throws(f.foldVals)
throws(() => f.foldVals(f.foldVals))
throws(() => f.foldVals('not struct', 10, add))
throws(() => f.foldVals(['not struct'], 10, add))

eq(Object.getPrototypeOf(f.mapVals(undefined, f.nop)), null)
eq(f.mapVals(undefined, add), {})
eq(f.mapVals({one: 1, two: 2}, add), {one: '1one', two: '2two'})
f.mapVals({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.mapVals)
throws(() => f.mapVals(f.mapVals))
throws(() => f.mapVals('not struct', id))
throws(() => f.mapVals(['not struct'], id))

eq(Object.getPrototypeOf(f.mapKeys(undefined, f.nop)), null)
eq(f.mapKeys(undefined, add), {})
eq(f.mapKeys({one: 1, two: 2}, add), {one1: 1, two2: 2})
f.mapKeys({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [['one', 10, 10, 20, 30], ['two', 20, 10, 20, 30]])
throws(f.mapKeys)
throws(() => f.mapKeys(f.mapKeys))
throws(() => f.mapKeys('not struct', id))
throws(() => f.mapKeys(['not struct'], id))

eq(f.mapValsSort(undefined, id), [])
eq(f.mapValsSort({3: 10, 22: 20, 111: 30}, id), [30, 20, 10])
f.mapValsSort({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.mapValsSort)
throws(() => f.mapValsSort(f.mapValsSort))
throws(() => f.mapValsSort('not struct', id))
throws(() => f.mapValsSort(['not struct'], id))

eq(Object.getPrototypeOf(f.pick(undefined, f.nop)), null)
eq(f.pick(undefined, id), {})
eq(f.pick({one: 10, two: NaN}, id), {one: 10})
f.pick({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.pick)
throws(() => f.pick(f.pick))
throws(() => f.pick('not struct', id))
throws(() => f.pick(['not struct'], id))

eq(Object.getPrototypeOf(f.omit(undefined, f.nop)), null)
eq(f.omit(undefined, id), {})
eq(f.omit({one: 10, two: NaN}, id), {two: NaN})
f.omit({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.omit)
throws(() => f.omit(f.omit))
throws(() => f.omit('not struct', id))
throws(() => f.omit(['not struct'], id))

eq(Object.getPrototypeOf(f.pickKeys()), null)
eq(f.pickKeys(undefined, undefined), {})
eq(f.pickKeys(undefined, []), {})
eq(f.pickKeys({}, undefined), {})
eq(f.pickKeys({one: 10, two: 20}, []), {})
eq(f.pickKeys({one: 10, two: 20}, ['one']), {one: 10})
throws(() => f.pickKeys(f.pickKeys))
throws(() => f.pickKeys('not struct', ['length']))
throws(() => f.pickKeys(['not struct'], ['length']))

eq(Object.getPrototypeOf(f.omitKeys()), null)
eq(f.omitKeys(undefined, undefined), {})
eq(f.omitKeys(undefined, []), {})
eq(f.omitKeys({}, undefined), {})
eq(f.omitKeys({one: 10, two: 20}, []), {one: 10, two: 20})
eq(f.omitKeys({one: 10, two: 20}, ['one']), {two: 20})
throws(() => f.omitKeys(f.omitKeys))
throws(() => f.omitKeys('not struct', []))
throws(() => f.omitKeys(['not struct'], []))

eq(f.findVal(undefined, id), undefined)
eq(f.findVal({one: 10}, id), 10)
eq(f.findVal({one: 10, two: [20]}, Array.isArray), [20])
f.findVal({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.findVal)
throws(() => f.findVal(f.findVal))
throws(() => f.findVal('not struct', id))
throws(() => f.findVal(['not struct'], id))

eq(f.findKey(undefined, id), undefined)
eq(f.findKey({one: 10}, id), 'one')
eq(f.findKey({one: 10, two: [20]}, Array.isArray), 'two')
f.findKey({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.findKey)
throws(() => f.findKey(f.findKey))
throws(() => f.findKey('not struct', id))
throws(() => f.findKey(['not struct'], id))

eq(f.everyVal(undefined, id),           true)
eq(f.everyVal({}, id),                  true)
eq(f.everyVal({one: 10, two: NaN}, id), false)
eq(f.everyVal({one: 10, two: 20}, id),  true)
f.everyVal({one: 10}, stash, 20, 30, 40)
eq(unstash(), [[10, 'one', 20, 30, 40]])
throws(f.everyVal)
throws(() => f.everyVal({}))
throws(() => f.everyVal('not struct', id))
throws(() => f.everyVal(['not struct'], id))

eq(f.someVal(undefined, id), false)
eq(f.someVal({}, id),        false)
eq(f.someVal({one: 0, two: NaN}, id),  false)
eq(f.someVal({one: 10, two: NaN}, id), true)
f.someVal({one: 10}, stash, 20, 30, 40)
eq(unstash(), [[10, 'one', 20, 30, 40]])
throws(f.someVal)
throws(() => f.someVal({}))
throws(() => f.someVal('not struct', id))
throws(() => f.someVal(['not struct'], id))

eq(Object.getPrototypeOf(f.invert()), null)
eq(f.invert(), {})
eq(f.invert({one: 10, two: 20}), {10: 'one', 20: 'two'})
throws(() => f.invert('not struct'))
throws(() => f.invert(['not struct']))

eq(Object.getPrototypeOf(f.invertBy(undefined, f.nop)), null)
eq(f.invertBy(undefined, id), {})
eq(f.invertBy({one: 10, two: 20}, id), {10: 'one', 20: 'two'})
f.invertBy({one: 10, two: 20}, stash, 10, 20, 30)
eq(unstash(), [[10, 'one', 10, 20, 30], [20, 'two', 10, 20, 30]])
throws(f.invertBy)
throws(() => f.invertBy(f.invertBy))
throws(() => f.invertBy('not struct', id))
throws(() => f.invertBy(['not struct'], id))
